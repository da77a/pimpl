[section Getting Started. Pimpl with Shared-Ownership Properties]

Let's begin with something basic and conventional

 struct Book
 {
    Book (string const& title, string const& author);
    ...
    string const&  title() const;
    string const& author() const;

    private:
  
    string  title_;
    string author_;
    int     price_;
 };


Say, due to reasons mentioned in the ['Introduction], we would like to deploy the ['Pimpl] technique with the ['shared/pointer] properties. In that setting the ['Book] definition might change as follows: 

 struct Book
 {
    Book(string const& title, string const& author);
    ...
    string const&  title() const;
    string const& author() const;
  
    bool operator== (Book const& other) const { return impl_ == other.impl_; }
    bool operator!= (Book const& other) const { return !operator==(other); }

    explicit operator bool () const { return  bool(impl_); }
    bool         operator! () const { return !bool(impl_); }
  
    private:
  
    struct implementation;
    std::shared_ptr<implementation> impl_;
 };

Applying the ['Pimpl] idiom is fairly straightforward as ['std::shared_ptr] takes care of much of the implementation-related hassle. The auto-generated ['special member functions] (the destructor, the copy constructor, etc.) suffice and writing the comparison, Boolean-conversion operators is straightforward.

Still, from design perspectives lumping the application logic with the infrastructure scaffolding is unfortunate. In our (admittedly simple) example more than half of the code is the ['Pimpl]-related implementation detail. For one class in isolation that might not be that big a deal. On a larger scale though, reading, understanding and maintaining extra code, mentally separating the application logic from the infrastructure detail, making sure nothing is forgotten, misused, or misplaced is a tiring and error-prone exercise. The following, therefore, seems like an improvement: 

 struct Book : impl_ptr<Book>::shared
 {
    Book(string const& title, string const& author);
    
    string const&  title() const;
    string const& author() const;
 };

With no loss in functionality it is shorter, application-focused and reasonably self-documented. The most important quality though is that it consists of nothing but ['pure application-specific interface]. It is not even a class as there is nothing to restrict access to. 

[note With such a clean ['separation of concerns] (public interface and private implementation) the technique is ideal for building large-scale systems and, importantly, managing orderly evolution of those systems. 

In general, large-scale systems are easier evolved and maintained if they follow the principle which might be described as the ['API-centered design]. For such systems considerable initial effort goes into designing interface specifications for modules/components (high-level/architectural design) and classes (low-level/detailed design). That allows further development to proceed to a large degree in parallel -- with the service-consumer relying on those contractual obligations (imposed by the API) and with the service-provider working towards meeting those contractual obligations. The better/cleaner the interface/implementation separation of concerns is, the fewer there are interruptions of that parallel development process.]

[endsect]
