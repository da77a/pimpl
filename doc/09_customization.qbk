[section Customization]
[section Custom Allocator]
TODO

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, my_allocator<implementation>(), title, author)
 {} 

[endsect] 
[section Custom Proxy-Implementation Relationship Policy]

An important property of the library is its extendibility. It currently provides several policies but more are easy to incorporate. For example, a ['copy-on-write] policy might be one such extension. Then, a stack-based-implementation policy might be another.

 template<typename impl_type, size_t allocated_size>
 struct detail::onstack
 {
     // Proof of concept
     char storage_[allocated_size];
 
     template<typename derived_type, typename... arg_types>
     void
     emplace(arg_types&&... args)
     {
         static_assert(sizeof(derived_type) <= allocated_size, "");
 
         new (storage_) derived_type(std::forward<arg_types>(args)...);
     }
     impl_type* get () const { return (impl_type*) storage_; }
 
     onstack () =default;
 };
 template<typename user_type>
 struct impl_ptr
 { ...
     template<size_t sz> using onstack = base<detail::onstack<implementation, sz>>;
 };
 ...
 struct Book : boost::impl_ptr<Book>::onstack<32> { ... };

[endsect] 
[endsect] 

