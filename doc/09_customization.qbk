[section Customization]
[section Custom Proxy-Implementation Relationship Policy]

An important property of the library is its extendibility. It currently provides several policies but more are easy to incorporate. For example, a ['copy-on-write] policy might be one such extension. Then, a stack-based-implementation policy might be another:

 template<typename impl_type, size_t sz>
 struct detail::onstack // Proof of concept
 {
     using buffer = char[sz];
 
     buffer storage_ = {0};
     bool     valid_ = 0;
 
     template<typename derived_type, typename... arg_types>
     void
     emplace(arg_types&&... args)
     {
         static_assert(sizeof(derived_type) <= sz, "");
 
         new (storage_) derived_type(std::forward<arg_types>(args)...);
         valid_ = true;
     }
     impl_type* get () const { return valid_ ? (impl_type*) storage_ : nullptr; }
 
     onstack () =default;
 };
 template<typename user_type>
 struct impl_ptr
 { ...
     template<size_t sz> using onstack = base<detail::onstack<implementation, sz>>;
 };
 ...
 struct Book : boost::impl_ptr<Book>::onstack<32> { ... };

[endsect] 
[section Custom Allocator]
TODO

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, my_allocator<implementation>(), title, author)
 {} 

[endsect] 
[endsect] 

