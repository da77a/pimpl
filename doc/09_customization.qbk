[section Customization]
[section Custom Proxy-Implementation Relationship Policy]

An important property of the library is its extendibility. It currently provides several policies but more are easy to incorporate. For example, a ['copy-on-write] policy might be one such extension. Then, a stack-based-implementation policy might be another:

 template<typename impl_type, size_t sz>
 struct detail::onstack // Proof of concept
 {
     using buffer = char[sz];
 
     buffer storage_ = {0};
     bool     valid_ = 0;
 
     template<typename derived_type, typename... arg_types>
     void
     emplace(arg_types&&... args)
     {
         static_assert(sizeof(derived_type) <= sz, "");
 
         new (storage_) derived_type(std::forward<arg_types>(args)...);
         valid_ = true;
     }
     impl_type* get () const { return valid_ ? (impl_type*) storage_ : nullptr; }
 
     onstack () =default;
 };
 template<typename user_type>
 struct impl_ptr
 { ...
     template<size_t sz> using onstack = base<detail::onstack<implementation, sz>>;
 };
 ...
 struct OnStack : boost::impl_ptr<OnStack>::onstack<32> { ... };

then ['OnStack] can be used as any other ['Pimpl]-based objects:

 OnStack s11 (3); BOOST_TEST(s11.value() == 3);
 OnStack s12 (5); BOOST_TEST(s12.value() == 5);
 OnStack s13 = OnStack::null();

 // Check that implementation is allocated on the stack.
 BOOST_TEST((void*) &s11 == (void*) &*s11);
 BOOST_TEST(!s13);

 s11 = s12;          BOOST_TEST(s11.value() == 5);
 s11 = OnStack(6);   BOOST_TEST(s11.value() == 6);

[endsect] 
[section Custom Allocator]
TODO

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, my_allocator<implementation>(), title, author)
 {} 

[endsect] 
[endsect] 

