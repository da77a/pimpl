[section Customization]
[section Custom Proxy-Implementation Relationship Policy]

An important property of ['impl_ptr] is its extendibility. It currently provides several policies but more are easy to incorporate. For example, a ['copy-on-write] policy might be one such extension. Then, a ['stack-based-implementation] policy might be another:

 template<typename impl_type, size_t sz>
 struct detail::onstack // Proof of concept
 {
     using real_traits_type = detail::traits::onstack_type<impl_type>;
     using base_traits_type = detail::traits::base<impl_type>;
     using     storage_type = typename boost::aligned_storage<sz, 8>::type;
 
    ~onstack () { if (traits_) traits_->destroy(get()); }
     onstack () {}
     onstack (this_type const& o)
     :
         traits_(o.traits_)
     {
         if (traits_)
             traits_->construct(get(), o.get());
     }
     template<typename derived_type, typename... arg_types>
     void
     emplace(arg_types&&... args)
     {
         static_assert(sizeof(derived_type) <= sz, "");
 
         ::new (storage_.address()) derived_type(std::forward<arg_types>(args)...);
         traits_ = real_traits_type();
     }
     impl_type* get() const 
     { 
         return traits_ ? (impl_type*) storage_.address() : nullptr; 
     }

     ...
 
     private:
 
     storage_type           storage_;
     base_traits_type const* traits_ = nullptr;
 };
 template<typename user_type>
 struct impl_ptr
 { ...
     template<size_t sz> using onstack = base<detail::onstack<implementation, sz>>;
 };
 ...
 struct OnStack : boost::impl_ptr<OnStack>::onstack<32> { ... };

Then ['OnStack] could be used no differently from other ['Pimpl]-based objects:

 OnStack s11 (3); BOOST_TEST(s11.value() == 3);
 OnStack s12 (5); BOOST_TEST(s12.value() == 5);
 OnStack s13 = OnStack::null();

 // Check that implementation is allocated on the stack.
 BOOST_TEST((void*) &s11 == (void*) &*s11);
 BOOST_TEST(!s13);

 s11 = s12;          BOOST_TEST(s11.value() == 5);
 s11 = OnStack(6);   BOOST_TEST(s11.value() == 6);

or a switch from

 struct Book : boost::impl_ptr<Book>::copied { ... }; // Heap-based implementation allocation

to

 struct Book : boost::impl_ptr<Book>::onstack<32> { ... }; // Stack-based implementation allocation

could be done later due to efficiency requirements or heap constraints with minimal or no disruption to the existing code. 

[endsect] 
[section Custom Allocator]
TODO

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, my_allocator<implementation>(), title, author)
 {} 

[endsect] 
[endsect] 

