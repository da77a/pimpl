[section Construction and Book::null()]

Ð¢he ['Pimpl] base class (aliased as ['impl_ptr_type]) is initialized with:

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, title, author)
 {} 
 
The first ['in_place] argument is the disambiguation tag indicating that the underlying ['impl_ptr<Book>::implementation] is constructed in-place with the remaining arguments. Consequently, a ['Book] constructor with no matching ['impl_ptr<Book>::implementation] constructor will fail to compile. 

That same mechanism works for the default constructor as well. That is, 

 Book::Book() : impl_ptr_type(in_place) {}
 
will try calling the default ['implementation()] constructor and will fail to compile if there is no such.

To avoid potential confusion ['impl_ptr] does not have the default constructor. To create a proxy with no implementation use ['Book::null()]:

 Book::Book() : impl_ptr_type(null())
 {
    // A Book proxy object is created with no implementation behind it
 }
 
 void
 Book::do_something()
 {
    if (!*this)
    {
        // Implementation is created later.
        this->emplace<implementation>(...);
    }
    ...
 } 
 
In the example the underlying ['impl_ptr_type] and, consequently, ['Book] are created "invalid" (like ['nullptr] or an empty ['std::shared_ptr())]. Later a ['pimpl<Book>::implementation] instance is explicitly created using ['emplace<implementation>()]. 

The ['impl_ptr] library generalizes that ['nullptr]-like concept via ['impl_ptr<Book>::null()] and its convenience ['Book::null()] interface. That is useful for lazy-instantiation optimization (as in the example above) or to support dynamic polymorphism that is discussed later or to indicate a no-book condition: 

 Book
 find_book()
 {  ...
    return Book::null(); // found nothing
 }
 ...
 if (Book book = find_book()) do something useful;
 else                         report book-not-found;
 
[endsect] 

