[section Construction and impl_ptr<Book>::null()]

Ð¢he ['Pimpl] base class (aliased as ['impl_ptr_type]) is initialized with:

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, title, author)
 {} 
 
Arguments passed to the ['impl_ptr_type] are forwarded to the corresponding ['impl_ptr<Book>::implementation] constructor. Consequently, a ['Book] constructor with no matching ['impl_ptr<Book>::implementation] constructor will fail to compile. 

That same mechanism works for the default constructor as well. That is, 

 Book::Book() : impl_ptr_type(in_place) {}
 
will try calling the default ['implementation()] constructor and will fail to compile if there is no such.

Sometimes it is beneficial to break that proxy-implementation association.

 Book::Book() : impl_ptr_type(impl_ptr<Book>::null())
 {
    // An invalid Book object is created with no implementation behind it
 }
 
 void
 Book::do_something()
 {
    if (!*this)
    {
        // Implementation is created later.
        this->emplace<implementation>(...));
    }
    ...
 } 
 
In the example the underlying ['pimpl_type] and, threrefore, ['Book] are created invalid (like ['nullptr] or an empty ['std::shared_ptr())]. Later a ['pimpl<Book>::implementation] instance is explicitly created and the ['pimpl_type] is assigned to manage it. 

The library generalizes that invalid-['Pimpl] concept and provides ['pimpl::null()]. That is useful for lazy-instantiation optimization (as in the example above) or to support dynamic polymorphism that is discussed later. It can be used to indicate a no-book condition: 

 Book
 find_book()
 {  ...
    return pimpl<Book>::null(); // found nothing
 }
 ...
 if (Book book = find_book()) do something useful;
 else                         report book-not-found;
 
[endsect] 

