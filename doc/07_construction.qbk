[section Construction and impl_ptr::null()]

Ð¢he ['Pimpl] base class (aliased as ['impl_ptr_type]) is initialized with:

 Book::Book(string const& title, string const& author)
 :
    impl_ptr_type(in_place, title, author)
 {} 
 
In line with ['std::optional, std::variant and std::any] the ['in_place] argument is the disambiguation tag indicating that the underlying ['impl_ptr<Book>::implementation] is constructed in-place with the remaining arguments. Consequently, a ['Book] constructor with no matching ['impl_ptr<Book>::implementation] constructor will fail to compile. That goes for the default constructor as well:

 Book::Book() : impl_ptr_type(in_place) {}
 
will try calling the default ['implementation()] constructor and will fail to compile if there is no such.

To avoid potential confusion ['impl_ptr_type] does not have the default constructor. To create a proxy with no implementation use ['Book::null()]:

 Book::Book() : impl_ptr_type(null())
 {
    // A Book proxy object is created with no implementation.
 }
 
 void
 Book::do_something()
 {
    if (!*this) // If no implementation, create one.
    {
        // Implementation is created later.
        impl_ptr_type::emplace(args);
    }
    ...
 } 
 
In the example the underlying ['impl_ptr_type] and, consequently, ['Book] are created "invalid" (like ['nullptr] or an empty ['std::shared_ptr())]. Later an ['impl_ptr_type<Book>::implementation] instance is explicitly created using ['impl_ptr_type::emplace()]. 

That ['nullptr]-like concept is generalized via ['impl_ptr<Book>::null()] and its convenience ['Book::null()] interface. That is useful for lazy-instantiation optimization (as in the example above) or to support dynamic polymorphism (as discussed later) or to indicate a no-book condition: 

 Book
 find_book()
 {  ...
    return Book::null(); // found nothing
 }
 ...
 if (Book book = find_book()) do something useful;
 else                         report book-not-found;
 
[endsect] 

