[section Custom Policy]

An important property of ['impl_ptr] is its extendibility. It currently provides several policies but more are easy to incorporate. For example, a ['copy-on-write] policy might be one such extension. Then, a ['stack-based-implementation] policy might be another:

 namespace detail
 {
     template<typename, typename =void> struct onstack;
 }
 
 template<typename impl_type, typename size_type>
 struct detail::onstack // Proof of concept
 {
     template<typename T =void> struct allocator : std::allocator<T>
     {
         void deallocate(T*, size_t) {}
 
         template<typename Y> struct rebind { using other = allocator<Y>; };
     };
     using    this_type = onstack;
     using storage_type = boost::aligned_storage<sizeof(size_type), sizeof(size_type)>;
     using  traits_type = detail::copyable_traits<impl_type, allocator<>>;
     using   traits_ptr = typename traits_type::pointer;
 
    ~onstack () { if (traits_) traits_->destroy(get()); }
     onstack () {}
     onstack (this_type const& o) : traits_(o.traits_)
     {
         if (traits_)
             traits_->construct(storage_.address(), *o.get());
     }
     ...
 
     private:
 
     storage_type storage_;
     traits_ptr    traits_ = nullptr;
 };
 template<typename user_type, typename... more_types>
 struct impl_ptr
 {
     using onstack = base<detail::onstack<impl_type, more_types...>>;
 };
 ...
 struct OnStack : boost::impl_ptr<OnStack, int[16]>::onstack { ... };

Then ['OnStack] could be used no differently from other ['Pimpl]-based objects:

 OnStack s11 (3); BOOST_TEST(s11.value() == 3);
 OnStack s12 (5); BOOST_TEST(s12.value() == 5);
 OnStack s13 = OnStack::null();

 // Check that implementation is allocated on the stack.
 BOOST_TEST((void*) &s11 == (void*) &*s11);
 BOOST_TEST(!s13);

 s11 = s12;          BOOST_TEST(s11.value() == 5);
 s11 = OnStack(6);   BOOST_TEST(s11.value() == 6);

or a switch from

 // Heap-based implementation allocation
 struct Book : boost::impl_ptr<Book>::copied { ... };

to

 // Stack-based implementation allocation
 struct Book : boost::impl_ptr<Book, char[64]>::onstack { ... };

could be done later due to efficiency requirements or heap constraints with minimal or no disruption to the existing code. 

[endsect] 

