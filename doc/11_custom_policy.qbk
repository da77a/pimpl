[section Custom Policy]

An important property of ['impl_ptr] is its extendibility. It currently provides several policies but more are easy to incorporate. For example, a ['copy-on-write] policy might be one such extension. Then, a restricted custom ['stack-based-implementation] policy (suggested by Giel van Schijndel) might be another:

 template<typename impl_type, typename size_type>
 struct onstack_no_null : detail::onstack<impl_type, size_type> // Proof of concept
 {
     using detail::onstack<impl_type, size_type>::onstack;

     // Disable the null-state construction.
     onstack_no_null(std::nullptr_t) =delete;
 };
 ...
 struct OnStack : boost::impl_ptr<OnStack, int[16]>::policy<onstack_no_null> { ... };

Then ['OnStack] could be used no differently from other ['Pimpl]-based classes:

 OnStack s11 (3); BOOST_TEST(s11.value() == 3);
 OnStack s12 (5); BOOST_TEST(s12.value() == 5);

 // The line below won't compile. OnStack does not have an uninitialized state.
 OnStack s13 = boost::impl_ptr<OnStack>::null();

 // Check that implementation is allocated on the stack.
 BOOST_TEST((void*) &s11 == (void*) &*s11);

 s11 = s12;          BOOST_TEST(s11.value() == 5);
 s11 = OnStack(6);   BOOST_TEST(s11.value() == 6);

[endsect] 

