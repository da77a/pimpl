<?xml version="1.0" standalone="yes"?>
<library-reference id="pimpl_reference"><title>Pimpl Reference</title><header name="boost/pimpl/pimpl.hpp"><class name="pimpl"><template>
      <template-type-parameter name="Interface"/>
    </template><purpose>Generalization of the Pimpl idiom. </purpose><class name="pimpl_base"><template>
      <template-nontype-parameter name="Manager"><type>template&lt; class &gt; class</type></template-nontype-parameter>
    </template><description><para>The base class behind pimpl::pointer_semantics and pimpl::value_semantics convenience typedefs. All pimpl-based classes derive from the class by <programlisting>      struct Foo : public <classname alt="pimpl">pimpl</classname>&lt;Foo&gt;::pointer_semantics { ... };
      struct Moo : public <classname alt="pimpl">pimpl</classname>&lt;Moo&gt;::value_semantics { ... };
</programlisting> </para></description><struct name="internal_type"/><typedef name="safebool"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="safebool_type"><type>safebool::type</type></typedef><typedef name="implementation"><type>implementation_type</type></typedef><typedef name="base_type"><type>pimpl_base_type</type></typedef><method-group name="public member functions"><method name="operator!" cv="const"><type>bool</type></method><method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type></method><method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype>pimpl_base_type const &amp;</paramtype></parameter></method><method name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype>T const &amp;</paramtype></parameter></method><method name="operator&lt;" cv="const"><type>bool</type><parameter name="that"><paramtype>pimpl_base_type const &amp;</paramtype></parameter></method><method name="swap" cv=""><type>void</type><parameter name="that"><paramtype>pimpl_base_type &amp;</paramtype></parameter></method><method name="swap" cv=""><type>void</type><parameter name="that"><paramtype>managed_type &amp;</paramtype></parameter></method><method name="use_count" cv="const"><type>long</type></method></method-group><method-group name="public static functions"><method name="null" cv=""><type>static T</type></method></method-group><method-group name="protected member functions"/><constructor/><constructor specifiers="explicit"><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><parameter name=""><paramtype>BOOST_PIMPL_DEPLOY_IF_NOT_PIMPL_DERIVED(A)</paramtype></parameter></constructor><constructor specifiers="explicit"><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><parameter name=""><paramtype>BOOST_PIMPL_DEPLOY_IF_NOT_PIMPL_DERIVED(A)</paramtype></parameter></constructor><constructor><parameter name="other"><paramtype><classname>pimpl_base</classname> &amp;&amp;</paramtype></parameter></constructor><constructor><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter></constructor><method-group name="private member functions"><method name="serialize" cv=""><type>void</type><template>
          <template-type-parameter name="Archive"/>
        </template><parameter name="a"><paramtype>Archive &amp;</paramtype></parameter><parameter name="int"><paramtype>unsigned</paramtype></parameter></method></method-group><constructor><parameter name=""><paramtype>internal_type</paramtype></parameter></constructor></class><class name="value_ptr"><template>
      <template-type-parameter name="Impl"/>
    </template><purpose>Smart-pointer with the value-semantics behavior. </purpose><description><para>It complements boost::shared_ptr which takes care of the pointer semantics behavior. The incomplete-type management technique is by Peter Dimov (see <ulink url="http://tech.groups.yahoo.com/group/boost/files/impl_ptr">http://tech.groups.yahoo.com/group/boost/files/impl_ptr</ulink>). </para></description><struct name="deep_copy"><inherit access="public">pimpl&lt; Interface &gt;::value_ptr::traits</inherit><method-group name="public member functions"><method name="destroy" cv="const"><type>void</type><parameter name="p"><paramtype>Impl *&amp;</paramtype></parameter></method><method name="copy" cv="const"><type>Impl *</type><parameter name="p"><paramtype>Impl const *</paramtype></parameter></method><method name="assign" cv="const"><type>void</type><parameter name="a"><paramtype>Impl *&amp;</paramtype></parameter><parameter name="b"><paramtype>Impl const *</paramtype></parameter></method><method name="conversion-operator" cv=""><type>traits const *</type></method></method-group></struct><struct name="null"><inherit access="public">pimpl&lt; Interface &gt;::value_ptr::traits</inherit><method-group name="public member functions"><method name="destroy" cv="const"><type>void</type><parameter name=""><paramtype>Impl *&amp;</paramtype></parameter></method><method name="copy" cv="const"><type>Impl *</type><parameter name=""><paramtype>Impl const *</paramtype></parameter></method><method name="assign" cv="const"><type>void</type><parameter name=""><paramtype>Impl *&amp;</paramtype></parameter><parameter name=""><paramtype>Impl const *</paramtype></parameter></method><method name="conversion-operator" cv=""><type>traits const *</type></method></method-group></struct><struct name="traits"><method-group name="public member functions"><method name="destroy" cv="const"><type>void</type><parameter name=""><paramtype>Impl *&amp;</paramtype></parameter></method><method name="copy" cv="const"><type>Impl *</type><parameter name=""><paramtype>Impl const *</paramtype></parameter></method><method name="assign" cv="const"><type>void</type><parameter name=""><paramtype>Impl *&amp;</paramtype></parameter><parameter name=""><paramtype>Impl const *</paramtype></parameter></method></method-group><destructor/></struct><method-group name="public member functions"><method name="operator&lt;" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype></parameter></method><method name="reset" cv=""><type>void</type><parameter name="p"><paramtype>Impl *</paramtype></parameter></method><method name="swap" cv=""><type>void</type><parameter name="that"><paramtype><classname>this_type</classname> &amp;</paramtype></parameter></method><method name="get" cv=""><type>Impl *</type></method><method name="get" cv="const"><type>Impl const *</type></method><method name="use_count" cv="const"><type>long</type></method></method-group><destructor/><constructor/><constructor><parameter name="p"><paramtype>Impl *</paramtype></parameter></constructor><constructor><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype></parameter></constructor><copy-assignment cv=""><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype></parameter></copy-assignment></class><typedef name="value_semantics"><purpose>Convenience typedef to deploy pimpl with value semantics. </purpose><description><para>The deployment technique is as follows: <programlisting>     struct Foo : public <classname alt="pimpl">pimpl</classname>&lt;Foo&gt;::value_semantics {...}
     struct Bar : public <classname alt="pimpl">pimpl</classname>&lt;Bar&gt;::pointer_semantics {...}
</programlisting> </para></description><type><classname>pimpl_base</classname>&lt; <classname>value_ptr</classname> &gt;</type></typedef><typedef name="pointer_semantics"><purpose>Convenience typedef to deploy pimpl with pointer semantics. </purpose><description><para>The deployment technique is as follows: <programlisting>     struct Foo : public <classname alt="pimpl">pimpl</classname>&lt;Foo&gt;::value_semantics {...}
     struct Bar : public <classname alt="pimpl">pimpl</classname>&lt;Bar&gt;::pointer_semantics {...}
</programlisting> </para></description><type><classname>pimpl_base</classname>&lt; boost::shared_ptr &gt;</type></typedef><method-group name="public static functions"><method name="null" cv=""><type>static Interface</type></method></method-group></class><class name="is_pimpl"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Implementation of the type-traits functionality for the pimpl. </purpose><description><para>is_pimpl&lt;Foo&gt;::value is 'true' if Foo directly or indirectly inherits from pimpl&lt;&gt;. Otherwise, is_pimpl&lt;Foo&gt;::value is 'false'. </para></description><method-group name="private static functions"><method name="tester" cv=""><type>static yes_type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>Y const *</paramtype></parameter><parameter name=""><paramtype>typename Y::pimpl_base_type const *</paramtype><default>0</default></parameter></method><method name="tester" cv=""><type>static no_type</type><parameter name=""><paramtype>...</paramtype></parameter></method></method-group><method-group name="public member functions"><method name="BOOST_STATIC_CONSTANT" cv=""><type/><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>value</paramtype><default>(1==sizeof(tester(ptr_type(0))))</default></parameter></method></method-group></class><macro name="BOOST_PIMPL_DEPLOY_IF_NOT_PIMPL_DERIVED" kind="functionlike"><macro-parameter name="A"/></macro><macro name="BOOST_SERIALIZATION_PIMPL_EXPLICIT_INSTANTIATIONS" kind="functionlike"><macro-parameter name="THE_CLASS"/></macro><macro name="BOOST_SERIALIZATION_PIMPL_REPLACE" kind="functionlike"><macro-parameter name="THE_CLASS"/></macro><macro name="BOOST_SERIALIZATION_PIMPL_INPLACE" kind="functionlike"><macro-parameter name="THE_CLASS"/></macro></header></library-reference>
